<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kitchen Timer System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>.p-safe{padding-bottom:env(safe-area-inset-bottom);padding-top:env(safe-area-inset-top);}</style>
</head>
<body class="bg-neutral-950 text-neutral-100">
  <div id="root"></div>

  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    const DEFAULT_TABLE_COUNT = 10;
    const MAX_STATUSES = 15;
    const LS_KEYS = { COURSES: "KHS_COURSES", TABLES: "KHS_TABLES", ASSIGN: "KHS_ASSIGNMENTS" };

    const makeId = (p = "id") => `${p}_${Math.random().toString(36).slice(2,8)}_${Date.now().toString(36)}`;

    const makeDefaultCourse = () => ({
      id: makeId("course"),
      name: "Default Course",
      statuses: [
        { id: makeId("st"), status: "Received", mode: "timer", alertAtSec: 300, message: "Order received" },
        { id: makeId("st"), status: "Prep", mode: "timer", alertAtSec: 600, message: "Prep in progress" },
        { id: makeId("st"), status: "Cook", mode: "countdown", durationSec: 600, alertAtSec: 120, message: "Finish cooking soon" },
        { id: makeId("st"), status: "Plate", mode: "timer", alertAtSec: 180, message: "Plating" },
        { id: makeId("st"), status: "Serve", mode: "timer", alertAtSec: 120, message: "Ready to serve" },
      ],
    });

    const makeDefaultTableState = (i) => ({ tableIndex: i, courseId: undefined, statusIndex: 0, startedAt: undefined, remainingSec: undefined, paused: true, completed: false });

    const makeDefaultAssignments = () => {
      const waiters = {};
      for (let i = 1; i <= 8; i++) {
        waiters[i] = { waiterId: i, displayName: `Waiter ${i}`, webhookUrl: "" };
      }
      return { tableWaiterMap: Array.from({ length: DEFAULT_TABLE_COUNT }, () => 0), waiters };
    };

    const loadCourses = () => { try { return JSON.parse(localStorage.getItem(LS_KEYS.COURSES)) || [makeDefaultCourse()]; } catch { return [makeDefaultCourse()]; } };
    const saveCourses = (x) => localStorage.setItem(LS_KEYS.COURSES, JSON.stringify(x));
    const loadTables  = () => { try { const t = JSON.parse(localStorage.getItem(LS_KEYS.TABLES)); if (Array.isArray(t) && t.length === DEFAULT_TABLE_COUNT) return t; } catch {} return Array.from({ length: DEFAULT_TABLE_COUNT }, (_, i) => makeDefaultTableState(i)); };
    const saveTables  = (x) => localStorage.setItem(LS_KEYS.TABLES, JSON.stringify(x));
    const loadAssignments = () => { try { return JSON.parse(localStorage.getItem(LS_KEYS.ASSIGN)) || makeDefaultAssignments(); } catch { return makeDefaultAssignments(); } };
    const saveAssignments = (x) => localStorage.setItem(LS_KEYS.ASSIGN, JSON.stringify(x));

    const formatHMS = (s = 0) => { s = Math.max(0, Math.floor(s)); const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60; return h>0 ? `${h}:${String(m).padStart(2,"0")}:${String(ss).padStart(2,"0")}` : `${m}:${String(ss).padStart(2,"0")}`; };
    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
    const classJoin = (...xs) => xs.filter(Boolean).join(" ");

    async function sendIFTTT(webhookUrl, message, tableLabel, statusName) {
      if (!webhookUrl) return { ok: false, error: "No webhook configured" };
      try {
        const res = await fetch(webhookUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ value1: message || `${statusName} alert`, value2: `${tableLabel} – ${statusName}`, value3: new Date().toISOString() }),
        });
        return { ok: res.ok, status: res.status };
      } catch (e) { return { ok: false, error: String(e) }; }
    }

    function computeCurrentTimer(ts, status) {
      if (!status) return { display: "--:--", currentRemaining: 0, elapsed: 0, warn: false, over: false, pct: 0 };
      const now = Date.now();
      const startedAt = ts.startedAt ?? now;
      const elapsed = Math.floor(Math.max(0, now - startedAt) / 1000);
      if (status.mode === "countdown") {
        const total = Math.max(0, status.durationSec ?? 0);
        const remaining = clamp((ts.paused ? (ts.remainingSec ?? total) : total - elapsed), 0, total);
        const warn = typeof status.alertAtSec === "number" && remaining <= status.alertAtSec && total > 0;
        const over = remaining === 0 && total > 0;
        const pct = total > 0 ? (remaining / total) : 0;
        return { display: formatHMS(remaining), currentRemaining: remaining, elapsed, warn, over, pct };
      } else {
        const alertAt = Math.max(0, status.alertAtSec ?? 0);
        const warn = elapsed >= alertAt && alertAt > 0;
        const pct = alertAt > 0 ? clamp(elapsed / alertAt, 0, 1) : 0.25;
        return { display: formatHMS(elapsed), currentRemaining: 0, elapsed, warn, over: false, pct };
      }
    }

    function advanceTime(ts, courses) {
      const course = courses.find(c => c.id === ts.courseId);
      const status = course?.statuses?.[ts.statusIndex];
      if (!status || ts.paused) return ts;
      const { currentRemaining, elapsed } = computeCurrentTimer(ts, status);
      const alertedKey = `KHS_ALERTED_${ts.tableIndex}_${ts.statusIndex}`;
      const alerted = sessionStorage.getItem(alertedKey) === "1";
      if (!alerted) {
        const shouldAlert = (status.mode === "countdown" && typeof status.alertAtSec === "number" && currentRemaining <= status.alertAtSec)
          || (status.mode === "timer" && typeof status.alertAtSec === "number" && elapsed >= status.alertAtSec);
        if (shouldAlert) { sessionStorage.setItem(alertedKey, "1"); triggerAutoAlert(ts.tableIndex, status); }
      }
      if (status.mode === "countdown" && currentRemaining === 0 && (status.durationSec ?? 0) > 0) return nextStatus(ts, courses);
      return ts;
    }

    async function triggerAutoAlert(tableIndex, status) {
      try {
        const assign = JSON.parse(localStorage.getItem(LS_KEYS.ASSIGN) || "null") || makeDefaultAssignments();
        const waiterId = assign.tableWaiterMap[tableIndex] || 0;
        const waiter = assign.waiters[waiterId];
        const label = `Table ${tableIndex + 1}`;
        await sendIFTTT(waiter?.webhookUrl, status?.message || `Alert for ${label}`, label, status?.status || "");
      } catch {}
    }

    function nextStatus(ts, courses) {
      const course = courses.find(c => c.id === ts.courseId);
      if (!course) return ts;
      const nextIndex = ts.statusIndex + 1;
      if (nextIndex >= course.statuses.length) return { ...ts, statusIndex: course.statuses.length - 1, paused: true, completed: true };
      const nextSt = course.statuses[nextIndex];
      const startedAt = Date.now();
      const remainingSec = nextSt.mode === "countdown" ? (nextSt.durationSec ?? 0) : undefined;
      try { sessionStorage.removeItem(`KHS_ALERTED_${ts.tableIndex}_${nextIndex}`); } catch {}
      return { ...ts, statusIndex: nextIndex, startedAt, remainingSec, paused: false, completed: false };
    }

    function NavButton({ active, onClick, children }) {
      return <button className={active ? "px-4 py-2 rounded-2xl text-sm font-medium bg-emerald-600 text-white" : "px-4 py-2 rounded-2xl text-sm font-medium bg-neutral-800 hover:bg-neutral-700"} onClick={onClick}>{children}</button>;
    }

    function Header({ tab, setTab }) {
      return (
        <header className="sticky top-0 z-10 bg-neutral-900/80 backdrop-blur border-b border-neutral-800">
          <div className="max-w-7xl mx-auto px-4 py-3 flex items-center gap-3">
            <div className="text-xl font-bold tracking-wide">Kitchen Timer System</div>
            <div className="ml-auto flex gap-2">
              <NavButton active={tab === "front"} onClick={() => setTab("front")}>Front</NavButton>
              <NavButton active={tab === "setup"} onClick={() => setTab("setup")}>Setup</NavButton>
              <NavButton active={tab === "waiters"} onClick={() => setTab("waiters")}>Waiters</NavButton>
            </div>
          </div>
        </header>
      );
    }

    function NumberInput({ label, value, onChange, min = 0, max = 86400 }) {
      return (<label className="text-xs text-neutral-300 flex items-center gap-1"><span className="opacity-80">{label}</span><input type="number" className="w-28 bg-neutral-800 rounded-xl px-2 py-1" value={value ?? 0} min={min} max={max} onChange={e => onChange(parseInt(e.target.value || "0", 10))} /></label>);
    }

    function StatusCircle({ warn, over, pct, label }) {
      const color = over ? "bg-red-600" : (warn ? "bg-amber-500" : "bg-emerald-600");
      const inset = Math.max(6, 6 + (1 - pct) * 42);
      return (
        <div className="relative w-24 h-24 shrink-0">
          <div className="absolute inset-0 rounded-full bg-neutral-800"></div>
          <div className="absolute inset-[6px] rounded-full bg-neutral-900 border border-neutral-700"></div>
          <div className={`${color} absolute rounded-full`} style={{ inset: `${inset}px` }}></div>
          <div className="absolute inset-0 grid place-items-center text-center px-2 text-xs leading-tight"><div>{label}</div></div>
        </div>
      );
    }

    function FrontPage({ courses, tables, assign, onTablesChange, onResetTable }) {
      const courseMap = useMemo(() => Object.fromEntries(courses.map(c => [c.id, c])), [courses]);
      const updateTable = (idx, patch) => onTablesChange(prev => prev.map(t => t.tableIndex === idx ? { ...t, ...patch } : t));

      async function handleCallWaiter(idx) {
        const t = tables[idx];
        const course = t.courseId ? courseMap[t.courseId] : undefined;
        const status = course?.statuses?.[t.statusIndex];
        const wId = assign.tableWaiterMap[idx] || 0;
        const waiter = assign.waiters[wId];
        const label = `Table ${idx + 1}`;
        const res = await sendIFTTT(waiter?.webhookUrl, status?.message || `Call waiter to ${label}`, label, status?.status || "");
        alert(res.ok ? `✅ Notified ${waiter?.displayName || "Waiter"}` : `⚠️ Failed: ${res.error || res.status}`);
      }

      function handleNext(idx) { onTablesChange(prev => prev.map(ts => ts.tableIndex === idx ? nextStatus(ts, courses) : ts)); }

      function handleStartPause(idx) {
        const t = tables[idx];
        const course = t.courseId ? courseMap[t.courseId] : undefined;
        const status = course?.statuses?.[t.statusIndex];
        const now = Date.now();
        if (!status) return;
        if (t.paused) {
          let startedAt = now;
          if (status.mode === "countdown") {
            const remain = t.remainingSec ?? status.durationSec ?? 0;
            startedAt = now - ((status.durationSec ?? 0) - remain) * 1000;
          }
          updateTable(idx, { paused: false, startedAt, completed: false });
        } else {
          const { currentRemaining } = computeCurrentTimer(t, status);
          updateTable(idx, { paused: true, remainingSec: currentRemaining });
        }
      }

      function handleCourseChange(idx, courseId) { updateTable(idx, { ...makeDefaultTableState(idx), courseId }); }

      return (
        <div className="max-w-7xl mx-auto px-3 py-4">
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-2 xl:grid-cols-2 gap-4">
            {tables.map((t, i) => {
              const course = t.courseId ? courses.find(c => c.id === t.courseId) : undefined;
              const status = course?.statuses?.[t.statusIndex];
              const { display, warn, over, pct } = computeCurrentTimer(t, status);
              const waiterId = assign.tableWaiterMap[i] || 0;
              const waiterName = waiterId ? assign.waiters[waiterId]?.displayName : "None";
              return (
                <div key={i} className="bg-neutral-900 rounded-2xl border border-neutral-800 p-4 flex flex-col gap-3">
                  <div className="flex items-center gap-2">
                    <div className="text-lg font-semibold">Table {i + 1}</div>
                    <span className="text-xs ml-2 px-2 py-0.5 rounded-full bg-neutral-800">Waiter: {waiterName || "None"}</span>
                    <button className="ml-auto text-xs px-3 py-1 rounded-full bg-neutral-800 hover:bg-neutral-700" onClick={() => onResetTable(i)}>Reset</button>
                  </div>
                  <div className="flex items-center gap-3">
                    <select className="bg-neutral-800 rounded-xl px-3 py-2 text-sm outline-none w-full" value={t.courseId || ""} onChange={e => handleCourseChange(i, e.target.value || undefined)}>
                      <option value="">Select Course</option>
                      {courses.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                    </select>
                  </div>
                  <div className="flex items-center gap-4">
                    <StatusCircle warn={warn} over={over} pct={pct} label={status ? status.status : "Idle"} />
                    <div className="flex-1">
                      <div className="text-2xl font-mono">{display}</div>
                      <div className="text-sm text-neutral-400">{status ? (status.mode === "countdown" ? "Countdown" : "Timer") : "No course selected"}</div>
                    </div>
                  </div>
                  <div className="flex gap-2 mt-2">
                    <button className={t.paused ? "flex-1 py-3 rounded-xl font-semibold bg-emerald-600" : "flex-1 py-3 rounded-xl font-semibold bg-amber-600"} onClick={() => handleStartPause(i)}>
                      {t.paused ? "Start/Resume" : "Pause"}
                    </button>
                    <button className="flex-1 py-3 rounded-xl bg-sky-600 font-semibold" onClick={() => handleNext(i)}>Next</button>
                    <button className="flex-1 py-3 rounded-xl bg-fuchsia-600 font-semibold" onClick={() => handleCallWaiter(i)}>Call Waiter</button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    function SetupPage({ courses, setCourses }) {
      const [selectedId, setSelectedId] = useState(courses[0]?.id);
      const selected = useMemo(() => courses.find(c => c.id === selectedId) || courses[0], [courses, selectedId]);
      const updateSelected = (patch) => setCourses(prev => prev.map(c => c.id === selected.id ? { ...c, ...patch } : c));
      const updateStatus = (idx, patch) => { const next = [...selected.statuses]; next[idx] = { ...next[idx], ...patch }; updateSelected({ statuses: next }); };
      const addStatus = () => { if (selected.statuses.length >= MAX_STATUSES) return alert("Max 15 statuses"); updateSelected({ statuses: [...selected.statuses, { id: makeId("st"), status: "New", mode: "timer", alertAtSec: 60, message: "Status alert" }] }); };
      const removeStatus = (idx) => updateSelected({ statuses: selected.statuses.filter((_, i) => i !== idx) });
      const move = (idx, dir) => { const j = idx + dir; if (j < 0 || j >= selected.statuses.length) return; const arr = [...selected.statuses]; [arr[idx], arr[j]] = [arr[j], arr[idx]]; updateSelected({ statuses: arr }); };
      const addCourse = () => { const c = makeDefaultCourse(); setCourses(prev => [...prev, { ...c, name: `Course ${prev.length + 1}` }]); setSelectedId(c.id); };
      const deleteCourse = () => { if (!confirm("Delete this course?")) return; const remaining = courses.filter(c => c.id !== selected.id); setCourses(remaining.length ? remaining : [makeDefaultCourse()]); setSelectedId(remaining[0]?.id || makeDefaultCourse().id); };

      return (
        <div className="max-w-5xl mx-auto px-3 py-6">
          <div className="flex items-center gap-2 mb-4">
            <select className="bg-neutral-800 rounded-xl px-3 py-2" value={selected.id} onChange={e => setSelectedId(e.target.value)}>
              {courses.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
            </select>
            <input className="bg-neutral-800 rounded-xl px-3 py-2 flex-1" value={selected.name} onChange={e => updateSelected({ name: e.target.value })} />
            <button className="px-3 py-2 rounded-xl bg-emerald-600" onClick={addCourse}>New Course</button>
            <button className="px-3 py-2 rounded-xl bg-red-600" onClick={deleteCourse}>Delete</button>
          </div>
          <div className="space-y-3">
            {selected.statuses.map((st, i) => (
              <div key={st.id} className="bg-neutral-900 rounded-2xl border border-neutral-800 p-3">
                <div className="flex items-center gap-2 mb-2">
                  <div className="text-sm px-2 py-1 rounded bg-neutral-800">#{i + 1}</div>
                  <input className="bg-neutral-800 rounded-xl px-3 py-2" value={st.status} onChange={e => updateStatus(i, { status: e.target.value })} />
                  <select className="bg-neutral-800 rounded-xl px-3 py-2" value={st.mode} onChange={e => updateStatus(i, { mode: e.target.value })}>
                    <option value="timer">Timer (count up)</option>
                    <option value="countdown">Countdown</option>
                  </select>
                  {st.mode === "countdown" ? (<>
                    <NumberInput label="Duration (sec)" value={st.durationSec ?? 0} onChange={v => updateStatus(i, { durationSec: v })} />
                    <NumberInput label="Alert at (sec remaining)" value={st.alertAtSec ?? 0} onChange={v => updateStatus(i, { alertAtSec: v })} />
                  </>) : (
                    <NumberInput label="Alert at (elapsed sec)" value={st.alertAtSec ?? 0} onChange={v => updateStatus(i, { alertAtSec: v })} />
                  )}
                  <input className="bg-neutral-800 rounded-xl px-3 py-2 flex-1" placeholder="IFTTT message" value={st.message || ""} onChange={e => updateStatus(i, { message: e.target.value })} />
                  <div className="ml-auto flex gap-2">
                    <button className="px-3 py-2 rounded-xl bg-neutral-800" onClick={() => move(i, -1)}>↑</button>
                    <button className="px-3 py-2 rounded-xl bg-neutral-800" onClick={() => move(i, +1)}>↓</button>
                    <button className="px-3 py-2 rounded-xl bg-red-600" onClick={() => removeStatus(i)}>Remove</button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          <div className="mt-4">
            <button className="px-4 py-3 rounded-2xl bg-sky-600" onClick={addStatus}>+ Add Status</button>
          </div>
        </div>
      );
    }

    function WaitersPage({ assign, setAssign }) {
      const setWaiterField = (id, patch) => setAssign(prev => ({ ...prev, waiters: { ...prev.waiters, [id]: { ...prev.waiters[id], ...patch } } }));
      const setTableWaiter = (idx, waiterId) => setAssign(prev => ({ ...prev, tableWaiterMap: prev.tableWaiterMap.map((w, i) => i === idx ? waiterId : w) }));
      async function testWebhook(id) { const w = assign.waiters[id]; const res = await sendIFTTT(w.webhookUrl, `Test ping for ${w.displayName}`, "Table X", "Test"); alert(res.ok ? "✅ Webhook OK" : `⚠️ ${res.error || res.status}`); }
      return (
        <div className="max-w-6xl mx-auto px-3 py-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div className="bg-neutral-900 rounded-2xl border border-neutral-800 p-4">
            <div className="text-lg font-semibold mb-3">Waiter Webhooks (1–8)</div>
            <div className="space-y-3">
              {Array.from({ length: 8 }, (_, i) => i + 1).map(id => {
                const w = assign.waiters[id];
                return (
                  <div key={id} className="bg-neutral-950 rounded-xl p-3 border border-neutral-800">
                    <div className="flex items-center gap-2 mb-2">
                      <div className="text-sm px-2 py-1 rounded bg-neutral-800">#{id}</div>
                      <input className="bg-neutral-800 rounded-xl px-3 py-2 flex-1" value={w.displayName} onChange={e => setWaiterField(id, { displayName: e.target.value })} />
                      <button className="px-3 py-2 rounded-xl bg-sky-600" onClick={() => testWebhook(id)}>Test</button>
                    </div>
                    <input className="w-full bg-neutral-800 rounded-xl px-3 py-2" placeholder="Full IFTTT webhook URL (e.g., https://maker.ifttt.com/trigger/your_event/with/key/your_key)" value={w.webhookUrl} onChange={e => setWaiterField(id, { webhookUrl: e.target.value })} />
                  </div>
                );
              })}
            </div>
          </div>
          <div className="bg-neutral-900 rounded-2xl border border-neutral-800 p-4">
            <div className="text-lg font-semibold mb-3">Assign Waiters to Tables</div>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {Array.from({ length: DEFAULT_TABLE_COUNT }, (_, i) => (
                <div key={i} className="bg-neutral-950 rounded-xl p-3 border border-neutral-800 flex items-center gap-2">
                  <div className="text-sm w-16">Table {i + 1}</div>
                  <select className="bg-neutral-800 rounded-xl px-3 py-2 flex-1" value={assign.tableWaiterMap[i] || 0} onChange={e => setTableWaiter(i, parseInt(e.target.value, 10))}>
                    <option value={0}>None</option>
                    {Array.from({ length: 8 }, (_, j) => j + 1).map(id => (
                      <option key={id} value={id}>{assign.waiters[id]?.displayName || `Waiter ${id}`}</option>
                    ))}
                  </select>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    function KitchenTimerSystem() {
      const [tab, setTab] = useState("front");
      const [courses, setCourses] = useState(loadCourses);
      const [tables, setTables] = useState(loadTables);
      const [assign, setAssign] = useState(loadAssignments);

      useEffect(() => saveCourses(courses), [courses]);
      useEffect(() => saveTables(tables), [tables]);
      useEffect(() => saveAssignments(assign), [assign]);

      useEffect(() => {
        const id = setInterval(() => {
          setTables(prev => prev.map(ts => advanceTime(ts, courses)));
        }, 1000);
        return () => clearInterval(id);
      }, [courses]);

      return (
        <div className="min-h-screen bg-neutral-950 text-neutral-100 p-safe pb-24">
          <Header tab={tab} setTab={setTab} />
          {tab === "front" && (
            <FrontPage
              courses={courses}
              tables={tables}
              assign={assign}
              onTablesChange={setTables}
              onResetTable={(i) => setTables(prev => prev.map(t => t.tableIndex === i ? makeDefaultTableState(i) : t))}
            />
          )}
          {tab === "setup" && (<SetupPage courses={courses} setCourses={setCourses} />)}
          {tab === "waiters" && (<WaitersPage assign={assign} setAssign={setAssign} />)}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<KitchenTimerSystem />);
  </script>
</body>
</html>
